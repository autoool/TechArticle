### Lesson2 基础架构：一条SQL查询语句是如何执行的 （两个重要日志，物理日志和逻辑日志）

#### MySQL架构图  InnoDB引擎

- ![mysql架构示意图](..\..\images\sql\mysql架构示意图.png =200X200)

#### 重要的日志模块： redo log

MySQL 里面的WAL技术

redo log 保证InnoDB 数据库异常重启，也不会丢失数据，这个能力称为crash-safe.

- 重要的日志模块：binlog (归档日志)

两种日志三点不同：

1）redo log 是InnoDB引擎特有的；binlog是MySQL 的server层实现的，所有引擎都可以使用

2）redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，

3）redo log 是循环写的，空间固定会用完；binlog是可以追加写入的，“追加写”是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

- update语句执行流程

![update执行流程](..\..\images\sql\update执行流程.png =200x200)

- 两阶段提交：

为了保证两份日志之间的逻辑一致。

备份临时库，进行恢复。
问题：数据库一天一备份跟一周已备份的对比
最长恢复时间更短，系统对应的指标就是RTO（恢复目标时间）。
因为更频繁全量备份需要消耗更多存储空间，所以RTO是成本换来的。
做法上要平衡业务重要性以及存储成本。


### Lesson3 事务隔离 为什么改了数据还是看不到？
事务支持是在引擎层做的。
事务：保证数据库的一组操作，要么全部成功，要么全部失败。
#### 隔离性与隔离级别
ACID（Atomicity, Consistency, Isolation, Durability  原子性，一致性，隔离性，持久性）。
多个事务同时执行时，会出现脏读（dirty read), 不可重复读（non-repeatable read）、幻读（phantom read) 的问题
隔离越严，效率越低。
- SQL事务隔离级别包括：（事务隔离如何通过视图实现）
1） 读未提交（read uncommitted): 
事务未提交时，它做的变更就能被别事务看到。
直接返回记录上的最新值，没有视图概念。
2)  读提交（read committed)：
事务提交后，它做的变更才会被其他事务看到。
视图在SQL语句开始执行的时候创建。
3)  可重复读（repeatable read)：
事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务是不可见的。
事务启动时，创建视图，整个事务存在期间都用这个视图。
4)  串行化 （serializable)：
对于同一记录，“写”会加“写锁，“读“会加”读锁"。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

在实现上，数据库会创建视图，访问时候以试图的逻辑为准。不同隔离级别，创建视图的时机不同。
Oracle数据库默认隔离级别是“读提交”，不同数据库之间迁移数据，保证数据库隔离级别一致。
Mysql 配置方式，将启动参数transaction-isolation 设置为READ-COMMITTED.

- “可重复读”使用场景：数据校验核对

#### 事务隔离的实现
回滚日志。
同一条记录在系统中存在多个版本，数据库的多版本并发控制（MVCC)。
当系统里没有比这个回滚日志更早的read-view的时候，删除该回滚日志。
- 尽量不要使用长事务：长事务意味着系统里会存在很老的事务视图，数据库可能使用到的回滚记录都必须保留，导致大量占用存储空间。长事务还占用锁资源，也可能拖垮整个库。
- 事务的启动方式：
  1） 显示启动事务语句，begin或start transaction 。配套提交语句是commit，回滚语句是rollback。
  2） set autocommit=0,这个命令会将这个线程的自动提交关闭。意味着如果你只执行一个select语句，这个事务就启动了，并且不会自动提交。这个事务持续存在知道你主动执行commit或rollback语句，或者断开连接。
  有些客户端框架会默认连接成功后先执行set autocommit=0 导致意外的长事务。
  建议总是使用set autocommit=1 通过显示语句的方式启动事务。
- “多一次交互”问题：
  对于需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。建议使用commit work and chain 语法。
  在autocommit 为1 的情况下，用begin显示启动事务，如果执行commit则提交事务。如果执行commit work and chain  则提交事务并自动启动下一个事务。省去再次执行begin语句的开销。

**思考题**：如何避免长事务对业务的影响？

从应用开发端来看：

1.确认是否使用了set autocommot=0,该确认可在测试环境中做。把MySQL的general_log开启，通过该日志确认。如果设置改成1 即可、

2.确认是否有不必要的只读事务。注意多个select 语句，只读不需要放在事务中。

3.业务连接数据库时，根据业务本身预估，通过 set max_execution_time 命令，来控制每个语句执行的最长时间。避免单个语句意外执行太长时间。

从数据库端来看：

1.设置长事务阈值，超过就警报或者kill

2.Percona的pt-kill工具使用

3.在业务功能阶段要求输出所有的general_log，分析日志找出问题。

4.使用5.6 或者更高版本，把innodb_undo_tablessapces设置成2（或者更大的值）。如果真的出现大事务导致回滚段过大，这样设置后面清理起来也方便。

**存在的疑问**：问题法
1）读提交，当对方没有提交时候，是否其它事务不能读？
2）脏读、不可重复读、幻读分别在什么情况下会出现？

3）思考题中**为什么意外，后面会有讨论**

### Lesson4 深入浅出索引（上）

索引为了提高查询效率。

#### 索引的常见模型

提高读写效率的数据结构：哈希表，有序数组和搜索树。

因为不是有序的，哈希索引做区间查询的速度回很慢。

- 哈希表这种结构适用于只有等值查询的场景。



- 有序数组在等值查询和范围查询场景中的性能非常优秀。

查询效率高，但是更新或者插入数据需要挪动后面所有的数据，成本太高。

按照顺序保存，可使用二分法查询。

有序数组索引只适用于静态存储引擎。（存储后不再修改的数据）

- 二叉搜索树 时间复杂度O(log(N))

为了让一个查询尽量少读磁盘，就必须让查询过程访问尽量少的数据块。使用“N叉”树，N取决于数据块的大小。

其它技术方案：跳表、LSM树等数据结构

数据库底层存储的核心是基于数据结构，从数据模型分析该数据库的使用场景。

#### InnoDB的索引模型 采用B+树结构

主键索引也成为聚簇索引，非主键索引也成为二级索引。

- 基于主键索引和普通索引的查询有什么区别？

主键索引叶子节点存储的是整行数据，非主键索引存储的是主键的值。

普通索引比主键索引多一个回表过程，需要多扫描一颗索引树。

普通索引的过程：非主键字段k建立索引，普通索引查询方式，需要先搜索k的索引树，拿到主键，再根据主键索引树搜索一次（回表）。

#### 索引维护

案例讨论：建表规范里面，建表语句里面一定要有自增主键

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**从性能和存储空间方面考量，自增主键是更合理的选择**。

哪些场景适合用业务字段直接做主键（KV场景）：

因为没有其他索引，所以不用考虑其他索引的叶子节点大小问题。

1、 只有一个索引

2、该索引必须是唯一索引

思考题：重建索引两种方式，有什么不合适的，更好的方法是什么？

alter table T drop index k;
alter table T add index(k);
alter table T drop primary key;
alter table T add primary key(id);

回答：重建主键索引，对普通索引有影响，会使得所有的二级索引失效。

1）二级索引索引的内容是主键，删除主键，二级索引内容就没了。并且会用RowId来做主键索引

2）mysql官网三种措施：(1)整个数据库迁移，先dump出来再重建表 (2)用空的alter操作，alter table t1 engine=innoDB;  

(3) repaire table ，由存储引擎决定是否支持。

**问题**

1）select id，name 写明字段与select * 效率问题

select *要读和拷贝更多列到server,还要发送更多列给客户端，所以还是select id更快。

2）N叉树的N是否可以指定？

5.6以后，可以通过page大小来调整。计算方法，前缀索引。

3）InnoDB引擎的表，数据量非常大，根据二级索引比用主键索引快，原因是主键索引和数据行在一起。通过二级索引查找后，还要根据主键索引，为什么二级索引反而快，原因是什么？

4）页面分裂和页面合并？

增加空间利用率

5）联合索引在B+树种的存储方式

6）什么情况下需要建索引？

能够带来查询收益，特别是有可能变成大表

7）非聚集索引上为什么叶子节点不是数据地址？

对组织表，MyISAM 

8）分库分表自增主键如何做？

9）05篇 “最左前缀原则”这一段





































