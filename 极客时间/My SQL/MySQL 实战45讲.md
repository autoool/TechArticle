### Lesson2 基础架构：一条SQL查询语句是如何执行的 （两个重要日志，物理日志和逻辑日志）

#### MySQL架构图  InnoDB引擎

- ![mysql架构示意图](..\..\images\sql\mysql架构示意图.png =200X200)

#### 重要的日志模块： redo log

MySQL 里面的WAL技术

redo log 保证InnoDB 数据库异常重启，也不会丢失数据，这个能力称为crash-safe.

- 重要的日志模块：binlog (归档日志)

两种日志三点不同：

1）redo log 是InnoDB引擎特有的；binlog是MySQL 的server层实现的，所有引擎都可以使用

2）redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，

3）redo log 是循环写的，空间固定会用完；binlog是可以追加写入的，“追加写”是指binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

- update语句执行流程

![update执行流程](..\..\images\sql\update执行流程.png =200x200)

- 两阶段提交：

为了保证两份日志之间的逻辑一致。

备份临时库，进行恢复。
问题：数据库一天一备份跟一周已备份的对比
最长恢复时间更短，系统对应的指标就是RTO（恢复目标时间）。
因为更频繁全量备份需要消耗更多存储空间，所以RTO是成本换来的。
做法上要平衡业务重要性以及存储成本。


### Lesson3 事务隔离 为什么改了数据还是看不到？
事务支持是在引擎层做的。
事务：保证数据库的一组操作，要么全部成功，要么全部失败。
#### 隔离性与隔离级别
ACID（Atomicity, Consistency, Isolation, Durability  原子性，一致性，隔离性，持久性）。
多个事务同时执行时，会出现脏读（dirty read), 不可重复读（non-repeatable read）、幻读（phantom read) 的问题
隔离越严，效率越低。
- SQL事务隔离级别包括：（事务隔离如何通过视图实现）
1） 读未提交（read uncommitted): 
事务未提交时，它做的变更就能被别事务看到。
直接返回记录上的最新值，没有视图概念。
2)  读提交（read committed)：
事务提交后，它做的变更才会被其他事务看到。
视图在SQL语句开始执行的时候创建。
3)  可重复读（repeatable read)：
事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务是不可见的。
事务启动时，创建视图，整个事务存在期间都用这个视图。
4)  串行化 （serializable)：
对于同一记录，“写”会加“写锁，“读“会加”读锁"。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

在实现上，数据库会创建视图，访问时候以试图的逻辑为准。不同隔离级别，创建视图的时机不同。
Oracle数据库默认隔离级别是“读提交”，不同数据库之间迁移数据，保证数据库隔离级别一致。
Mysql 配置方式，将启动参数transaction-isolation 设置为READ-COMMITTED.

- “可重复读”使用场景：数据校验核对

#### 事务隔离的实现
回滚日志。
同一条记录在系统中存在多个版本，数据库的多版本并发控制（MVCC)。
当系统里没有比这个回滚日志更早的read-view的时候，删除该回滚日志。
- 尽量不要使用长事务：长事务意味着系统里会存在很老的事务视图，数据库可能使用到的回滚记录都必须保留，导致大量占用存储空间。长事务还占用锁资源，也可能拖垮整个库。
- 事务的启动方式：
  1） 显示启动事务语句，begin或start transaction 。配套提交语句是commit，回滚语句是rollback。
  2） set autocommit=0,这个命令会将这个线程的自动提交关闭。意味着如果你只执行一个select语句，这个事务就启动了，并且不会自动提交。这个事务持续存在知道你主动执行commit或rollback语句，或者断开连接。
  有些客户端框架会默认连接成功后先执行set autocommit=0 导致意外的长事务。
  建议总是使用set autocommit=1 通过显示语句的方式启动事务。
- “多一次交互”问题：
  对于需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次“begin”，减少了语句的交互次数。建议使用commit work and chain 语法。
  在autocommit 为1 的情况下，用begin显示启动事务，如果执行commit则提交事务。如果执行commit work and chain  则提交事务并自动启动下一个事务。省去再次执行begin语句的开销。

**思考题**：如何避免长事务对业务的影响？

从应用开发端来看：

1.确认是否使用了set autocommot=0,该确认可在测试环境中做。把MySQL的general_log开启，通过该日志确认。如果设置改成1 即可、

2.确认是否有不必要的只读事务。注意多个select 语句，只读不需要放在事务中。

3.业务连接数据库时，根据业务本身预估，通过 set max_execution_time 命令，来控制每个语句执行的最长时间。避免单个语句意外执行太长时间。

从数据库端来看：

1.设置长事务阈值，超过就警报或者kill

2.Percona的pt-kill工具使用

3.在业务功能阶段要求输出所有的general_log，分析日志找出问题。

4.使用5.6 或者更高版本，把innodb_undo_tablessapces设置成2（或者更大的值）。如果真的出现大事务导致回滚段过大，这样设置后面清理起来也方便。

**存在的疑问**：问题法
1）读提交，当对方没有提交时候，是否其它事务不能读？
2）脏读、不可重复读、幻读分别在什么情况下会出现？

3）思考题中**为什么意外，后面会有讨论**

### Lesson4 深入浅出索引（上）

索引为了提高查询效率。

#### 索引的常见模型

提高读写效率的数据结构：哈希表，有序数组和搜索树。

因为不是有序的，哈希索引做区间查询的速度回很慢。

- 哈希表这种结构适用于只有等值查询的场景。



- 有序数组在等值查询和范围查询场景中的性能非常优秀。

查询效率高，但是更新或者插入数据需要挪动后面所有的数据，成本太高。

按照顺序保存，可使用二分法查询。

有序数组索引只适用于静态存储引擎。（存储后不再修改的数据）

- 二叉搜索树 时间复杂度O(log(N))

为了让一个查询尽量少读磁盘，就必须让查询过程访问尽量少的数据块。使用“N叉”树，N取决于数据块的大小。

其它技术方案：跳表、LSM树等数据结构

数据库底层存储的核心是基于数据结构，从数据模型分析该数据库的使用场景。

#### InnoDB的索引模型 采用B+树结构

主键索引也成为聚簇索引，非主键索引也成为二级索引。

- 基于主键索引和普通索引的查询有什么区别？

主键索引叶子节点存储的是整行数据，非主键索引存储的是主键的值。

普通索引比主键索引多一个回表过程，需要多扫描一颗索引树。

普通索引的过程：非主键字段k建立索引，普通索引查询方式，需要先搜索k的索引树，拿到主键，再根据主键索引树搜索一次（回表）。

#### 索引维护

案例讨论：建表规范里面，建表语句里面一定要有自增主键

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**从性能和存储空间方面考量，自增主键是更合理的选择**。

哪些场景适合用业务字段直接做主键（KV场景）：

因为没有其他索引，所以不用考虑其他索引的叶子节点大小问题。

1、 只有一个索引

2、该索引必须是唯一索引

思考题：重建索引两种方式，有什么不合适的，更好的方法是什么？

alter table T drop index k;
alter table T add index(k);
alter table T drop primary key;
alter table T add primary key(id);

参考答案：重建主键索引，对普通索引有影响，会使得所有的二级索引失效。

重建索引k的做法合理，重建主键不合理。无论删除主键还是创建主键，都会重建表。所以连着执行两个语句，重建索引k的语句等于白做。

重建索引的过程会创建一个新的索引，把数据按顺序插入，这样的页面利用率最高，索引更紧凑、更省空间。

1）二级索引索引的内容是主键，删除主键，二级索引内容就没了。并且会用RowId来做主键索引

2）mysql官网三种措施：(1)整个数据库迁移，先dump出来再重建表 (2)用空的alter操作，alter table t1 engine=innoDB;  

(3) repaire table ，由存储引擎决定是否支持。

**问题**

1）select id，name 写明字段与select * 效率问题

select *要读和拷贝更多列到server,还要发送更多列给客户端，所以还是select id更快。

2）N叉树的N是否可以指定？

5.6以后，可以通过page大小来调整。计算方法，前缀索引。

3）InnoDB引擎的表，数据量非常大，根据二级索引比用主键索引快，原因是主键索引和数据行在一起。通过二级索引查找后，还要根据主键索引，为什么二级索引反而快，原因是什么？

4）页面分裂和页面合并？

增加空间利用率

5）联合索引在B+树种的存储方式

6）什么情况下需要建索引？

能够带来查询收益，特别是有可能变成大表

7）非聚集索引上为什么叶子节点不是数据地址？

对组织表，MyISAM 

8）分库分表自增主键如何做？

9）05篇 “最左前缀原则”这一段

### Lesson5 深入浅出索引（下）

通过索引优化，避免回表过程。覆盖索引、前缀索引、索引下推

- 覆盖索引

select ID from T where k between 3 and 5;

由于ID已经在k的索引树上，因此可以直接提供查询结果，不需要回表，称为覆盖索引。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**

- 最左前缀原则

索引项是按照索引定义里面出现的字段顺序排序的。

只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以使联合索引的最左N个字段，也可以是字符串索引的最左M个字符。

- 建立联合索引的时候，如何安排索引里面的字段排序？

评估标准是索引的复用能力。

第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往是需要优先考虑采用的。（为高频请求创建联合索引）

第二个原则是空间原则，字段占的空间小。

- 索引下推

MySQL 5.6引入索引下推优化：在索引遍历过程中，对索引包含的字段优先判断，直接过滤掉不满足条件的记录，减少回表次数。

select * from tuser  where name like '张 %' and age=10 and ismale=1;

市民用户表 （name，age）建立索引

**思考题：**

primary key('a','b')

key c ('c')

key 'ca' ('c','a')

key 'cb' ('c','b')

是否还有必要建立ca 、cb索引？

参考答案：联合主键索引和索引组织表

主键 ab 相当于orde by a , b 先按照a排序，再按照b排序，c无序。

索引c 的组织，先按照c排序，同时记录主键（a ,b）记录的主键按照a先排序。

索引c a 的组织是先按照c 排序，再按照a 排序，同时记录主键（只有b）。此时的数据跟索引c的数据一样。

索引c b 的组织是先按照c 排序，再按照b 排序，同时记录主键（只有a)。

c作为索引，主键a b 会先根据a进行排序，b为无序。查询ca  ，不会进行回表。

查询cb ，由于b仍然是无序的，所以需要cb进行索引。这样b 就会有序。

ca索引 为什么和c索引一样，应为c索引回表返回的数据在主键索引已经排好序，所以不需要ca索引做排序。

**疑问：**

1）alter table T engine=InnoDB的作用？

InnoDB 引擎会导致，删除记录但是索引还存在，并未释放存储空间。只能重建表才能重建索引。

2) 查询数据 的段- 区 - 页 三个维度取数据

3）联合索引的技巧：

a.覆盖索引，通过普通索引查询主键或者联合索引的字段，不用回表

b.最左前缀

c.联合索引：联合索引的字段顺序，以最左原则进行where检索。

d.索引下推：MySQL 5.6版本之前会匹配数据进行回表查询，5.6版本之后，会先对联合索引里面的字段进行判断筛选，然后不在联合索引的字段再回表查询。

4）查询语句where条件里面各个判断调换顺序没关系

5）二级索引比主键索引更快，只有在覆盖索引时候成立。

6）where  in条件走不走索引？

优化器会估算代价

7）全表扫描的概念

8）回表是多个查询一起回表，还是一个个回表？

有mrr优化，就是一起回表，有更大概率是顺序访问主键数据。

9）覆盖索引如何实现？复合索引如何存储？

10）where in(1,2,3,4,5) 和 where between 1 and 5 区别

第一个树需要搜索5次，第二个搜索一次。

11）explain作用 ：显示mysql如何使用索引来处理select语句，以及连接表。

12）视图不能建索引，视图本身就是SQL语句，关键是优化视图定义。

13）MySQL在执行一条SQL时候，是如何选择使用哪个索引的，possible keys有很多个，根据什么选择用哪一个。

几个概念：索引统计信息、临时表成本、排序成本

### Lesson6 全局锁和表锁

#### 三类锁：全局锁，表锁，行锁

- 全局锁

使用场景，全库逻辑备份。

MySQL全局加锁命令：Flush tables with read lock(FTWRL)

整库只读存在的风险：

1）主库上备份，备份期间不能执行更新，业务基本停摆

2）从库上备份，备份期间从库不能执行主库同步过来的binlog，导致主从延迟。

官方备份工具 mysqldump

set global readonly=true 也可以让全库处于只读状态，为什么不用？

1）有些系统中，这个变量会用来做其他逻辑，比如主从库。

2）异常处理机制有差异，如果执行FTWRL 命令之后客户端发生异常断开，MySQL会自动释放全局锁，整个库回到可以正常更新状态；readonly 客户端发生异常，库也会一直处于只可读状态，导致整个库一直处于不可写状态，风险较高。

- 表级锁

MySQL表级锁有两种：一种是表锁，一种是元数据锁（meta data lock  MDL）。

- 表锁的语法 lock tables ……read/write.

unlock tables. 主动释放锁。

客户端断开连接也会自动释放。除了限制别的线程读写外，也限定了本线程接下来操作的对象。

MDL 元数据表锁：不需要显示使用，访问一个表的时候，自动加上。

读不需要加锁，写需要加锁。

- 另一类表级锁是MDL （metadata lock）

不需要显示使用，访问一个表的时候会自动加上。MDL的作用是保证读写的正确性。

MySQL 5.5 版本引入MDL，加MDL写锁：

- 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。
- 读写锁之间，写锁之间互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

#### 给一个小表增加字段，导致整个库挂掉？

给一个表增加、或者修改字段，需要扫描全表，特别是大表情况。

三个select语句，中间加一个alert修改表字段的语句，四个语句在一个事务里。alert语句会添加MDL锁之后，会造成整个表不可读写，会造成库的线程爆满。锁只会在事务提交后，才会释放。

首先解决长事务问题，事务不提交会一直占用MDL锁。特别是热点表，访问频繁。

如果表刚好有长事务在执行，考虑先暂定DDL，或者kill掉这个长事务。

**另一种场景**：如果修改的是一个热点表，请求很频繁。kill可能也不管用，因为新的请求马上就到。

解决方案: 比较理想的机制是，在alter table语句里面设置等待时间，如果在指定时间能够拿到MDL锁更好，如果拿不到也不要阻塞后面的业务语句，先放弃，之后通过开发人员或者DBA通过重试命令执行相关语句。

#### 小结

小表加字段，在低峰期做。

表锁一般都是在数据库引擎不支持行锁的时候使用。如果遇到有lock tables 和 unlock tables,需要追查一下原因，可能的情况如下：

1）系统还在使用不支持事务的引擎，需要安排升级引擎

2）要么就是引擎已经升级了，但是代码还没升级。需要业务开发把在 lock tables 和unlock tables  改成begin 和commit 问题应该就能解决。

MDL直到事务提交才会释放，在做表结构变更的时候，一定小心不要导致锁住线上查询和更新。

#### 思考题

备份在备库上执行，在备份过程中，如果在主库上做了一个DDL，从备份库上回看到什么现象？

个人想法：以前的数据，不会造成影响。备份从binlog进行备份。

**留言**

1）Online DDL过程  (DDL 数据定义语言  create /alter/drop/declare 修改操作)  

1. 拿MDL写锁

2. 降级成MDL读锁

3. 真正做DDL

4. 升级成MDL写锁

5. 释放MDL锁

   第三步占用了大部分时间，1 2 4 5 如果没有冲突，执行时间很短。

2） readonly 对用户超级super权限无效，执行binlog的线程是super权限。

3）数据库的请求是在一个队列里面（锁队列），前面没有释放的写锁，会阻塞后面所有的操作。5.6是先来先得到，5.7换了策略。

当备库用-single-transaction 做逻辑备份的时候，如果从主库的binlog传过来一个DDL语句会怎样？

假设这个DDL是针对表t1的，备份过程的关键语句如下：

Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；
/* other tables */
Q3:SAVEPOINT sp;
/* 时刻 1 */
Q4:show create table `t1`;
/* 时刻 2 */
Q5:SELECT * FROM `t1`;
/* 时刻 3 */
Q6:ROLLBACK TO SAVEPOINT sp;
/* 时刻 4 */
/* other tables */

参考答案：

1.如果在Q4语句执行之前到达,现象：没有影响，备份拿到的是DDL后的表结构

2.如果在‘时刻2’到达，则表结构被该国，Q5执行时候，报Table definition has changed, please retry transaction .

现象： mysqldump终止；

3.如果在‘时刻2’ 和 ‘时刻3’ 之间到达，mysqldump占着t1的MDL读锁，binlog被阻塞，现象：主从延迟，直到Q6执行完成。

4.从‘时刻4’开始，mysqldump释放了MDL读锁，现象：没有影响，备份拿到的是DDL前的表结构。

### Lesson7 行锁功过：怎么减少行锁对性能的影响？

MySQL行锁是由各个引擎自己实现的，并不是所有的引擎都支持行锁。

MylSAM引擎不支持行锁。

- 两阶段锁

下图事务B的update 语句执行时会是什么现象呢？假设字段id时表t的主键。

| 事务A                          | 事务B                          |
| ------------------------------ | ------------------------------ |
| begin：                        |                                |
| update t set k=k+1 where id=1; |                                |
| update t set k=k+1 where id=2; |                                |
|                                | begin；                        |
|                                | update t set k=k+2 where id=1; |
| commit;                        |                                |



参考答案：问题的结论在于事务A在执行完两条update语句之后，持有哪些锁，以及在什么时候释放。

实际上事务B的update语句会被阻塞，直到事务A 执行commit之后。

在InnoDB事务中，行锁实在需要的时候加上，但是并不是不需要了立即释放，而是要等到事务结束时才释放。这个就是**两阶段锁协议**。

*如果你的事务中需要锁多个行，要把最可能造成锁冲突 最可能影响并发度的锁尽量往后放*

eg:  电影票在线交易业务

1.从顾客A账户余额中扣除电影票价

2.给影院B的账户余额增加电影票价

3.记录一条交易日志

- 死锁和死锁检测

  | 事务A                                 | 事务B                          |
  | ------------------------------------- | ------------------------------ |
  | begin；update t set k=k+1 where id=1; | begin;                         |
  |                                       | update t set k=k+1 where id=2; |
  | update t set k=k+1 where id=2;        |                                |
  |                                       | update t set k=k+1 where id=1; |

  事务A和事务B互相等待对方的资源释放，就进入了死锁状态。出现死锁后，有两种策略：

  1） 直接进入等待，直到超时。这个超时时间可以通过参数innodb_lock_wait_timeout设置

  2） 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

  在InnoDB中，innodn_lock_wait_timeout的默认时间是50s,当出现死锁以后，第一个被锁住的线程要过50s才会超时推出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间无法接受。*该时间如果设置很小，会出现误伤。*正常情况下，采用第二种策略，主动死锁检测。

  **怎么解决热点行更行导致的性能问题，问题的症结在于死锁检测要耗费大量的CPU资源？**

  1）**关闭死锁检测**，定不会出现死锁，可临时把死锁检测关掉。关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。一般业务设计不会把死锁当作一个严重错误，当出现死锁，就回滚，通过业务重试一般就没问题，这是业务无损的。

  2）**控制并发度**。并发控制要在数据库服务端做，如果有中间件，可以考虑中间件实现；如果团队有可以修改MySQL源码的人，可以直接修改源码。*基本思路是，对于同行的更新，在进去引擎之前排队*，这样在InnoDB内部就不会有大量的死锁检测工作。

  3）考虑通过将一行改成逻辑上的多行来减少锁冲突。比如影院账户，可以放在多条记录上，影院账户总额等于这几条记录值的总和。但是，在扣除情况下，需要考虑当一条记录为0时候，需要特殊处理。

  **小结**

  1）开发时候如何正确安排事务语句：建议如果事务中需要锁多个行，要把最可能造成锁冲突/最可能影响并发度的锁的申请时机尽量往后放。

  2）调整语句顺序并不能完全避免死锁，引入死锁检测概念，并提供了三种方案。

  **思考*

  删除一个表里的10000条数据，有以下三种方法：

  1.直接执行 delete from T limit 10000;

  2.在一个连接中循环执行20次 delete from T limit 500;

  3.在20个连接中同时执行delete from T limit 500;

### lesson8 事务到底是隔离还是不隔离？




















































































