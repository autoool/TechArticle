## GC算法，垃圾回收器
###Garvage Collection
内存回收主要集中在java堆和方法区中，运行期间，这部分内存的分配和使用都是动态的。
- 对象存活判断
  1. 引用计数
  2. 可达性分析（Reachability Analysis）
    当一个对象到GC Roots没有任何引用链相连时，该对象不可用，为不可达对象。
    GC Roots包括：
  3. 虚拟机栈中引用的对象
  4. 方法区中类静态属性实体引用的对象
  5. 方法区中常量引用的对象
  6. 本地方法栈中JNI引用的对象
### 垃圾回收算法
1. 标记清除（Mark-Sweep）：分为标记和清除两个阶段。运行过程中需要分配大对象时无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。
  缺点：
   1）标记和清除过程效率不高
   2）标记清楚后产生大量不连续的内存碎片
2. 复制收集算法（Copying）：内存容量划分为大小相等的两块，每次只使用其中一块，当该块内存用完时，将存活对象复制到另一块上面，把已使用过的内存空间一次清理掉。
  优点：
   1）没有内存碎片问题
   2）实现简单，运行高效
  缺点：
   1）代价是把内存缩小为原来的一般，持续复制长生存期的对象导致效率降低。

3. 标记-压缩算法（Mark-Compact）
  复制算法，如果不想浪费50%的内存空间，需要额外的内存空间进行分配担保，以应对内存中所有对象都100%存活的情况，老年代一般不选用这种算法。
  针对老年代的特点，提出标记-压缩算法。标记过程和标记-清除算法一样，但是标记后不是对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。

4. 分代收集算法（Generational Collection）
  该算法把Java堆分为新生代和老年代，根据不同代的特点采用不同的算法。
  新生代中，因为每次垃圾收集都会有大量的对象死去，只有少量存活，所以采用复制算法。
  老年代中，因为对象存活率高、没有额外的空间进行分配担保，必须使用“标记-清除”或者“标记-整理”算法进行回收。

### 垃圾收集器
  收集算法是垃圾回收的方法论，垃圾收集器是内存回收的具体实现。

1. Serial收集器
  串行收集器，最稳定、效率最高，可能会产生较长的停顿，只使用一个线程去回收。
  新生代、老年代使用串行回收；
  **新生代复制算法，老年代标记-压缩**；
  垃圾回收过程中Stop The World(服务暂停)。
  参数控制：-XX：+UseSerialGC  

2. ParNew收集器
  Serial收集器多线程版本，依然会造成应用程序暂停。
  **新生代并行，老年代串行**；
  新生代复制算法，老年代标记-压缩算法；
  参数控制：
  -XX: +UseParNewGC
  -XX: +ParallelGCThreads 限制线程数量

3. Parallel收集器
	类似ParNew收集器，Parallel收集器更关注系统吞吐量。
	可通过参数打开自适应调节策略，虚拟机会根据系统当前运行情况收集性能监控信息，动态调整参数以提供自合适的停顿时间或最大吞吐量；
	也可以通过控制GC的时间不大于多少毫秒或者比例；
	新生代复制算法，老年代标记-压缩算法；
	参数控制：
	-XX: +UseParallelGC 使用Parallel收集器+老年代串行

4. Parallel Old收集器
	Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。JDK1.6开始提供。
	参数控制：
	-XX:+UseParallelOldGC  Parallel收集器+老年代并行
	
5. CMS收集器（Concurrent Mark Sweep）
	获取最短回收停顿时间为目标的收集器，基于“标记-清除”算法实现。**老年代收集器**新生代使用ParNew。
	整个过程分为4个步骤：
	1）初始标记（CMS initial makr）
	标记GC Roots能直接关联到的对象，速度很快
	2) 并发标记（CMS concurrent mark）
	GC Roots Tracing过程
	3) 重新标记 （CMS remark）
	修正并发标记期间，因用户程序继续运作而导致标记产生变动的对象标记记录，消耗时间比初始标记长，比并发标记时间短
	4) 并发清除 （CMS concurrent sweep）
	其中初始标记、重新标记两个步骤仍需要“Stop The World”。
	并发标记和并发清除耗时最长。
	内存回收过程与用户线程一起并发执行
	优点：并发收集、低停顿
	缺点：产生大量空间碎片、并发阶段会降低吞吐量
	参数控制：
	-XX:+UseConcMarkSweepGC  使用CMS收集器
	-XX:+UseCMSCompactAtFullCollection    Full GC之后，进行一次碎片整理；整理过程独占，会引起停顿时间变长
	-XX:+CMSFullGCsBeforeCompaction 设置进行几次Full GC之后，进行一次碎片整理
	-XX:ParallelCMDThreads 设定CMS的线程数量（一般可约等于可用CPU数量）

6. G1收集器
  - 相比CMS具有的特点：
  1）空间整合：采用标记-整理算法，不会产生内存空间碎片，分配大对象不会因为无法找到连续空间而提前触发下一次GC
  2）可预测停顿：建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫米的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。
  Java堆的内存布局和其他收集器有很大差异，将整个Java堆划分为多个大小相等的独立区域（Region）,虽然保留了新生代和老年代的概念，但是新生代和老年代不再是物理隔阂，它们都是一部分（可以不连续）Region的集合。
  ![Region](..\images\java\Region.jpg)![G1收集器]
  - 收集步骤
  1） **标记阶段**：首先初始标记(Iniial-Mark)，这个阶段是停顿的，并且会触发一次普通的Mintor GC. 对应GC log：GC pause (young) (inital-mark)
  2) **Root Region Scanning**:  程序运行过程中会回收survivor区（存活到老年代），这一过程必须在young GC之前完成。
  3) **Concurrent Marking **: 整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，这个区域会被立即回收（图中X）。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
![G1收集器](..\images\java\G1收集器.png)
  4) ** Remark** 再标记，会有短暂的停顿。该阶段是用来收集在并发标记阶段产生新的垃圾；G1中采用了比CMS更快的初始快照算法：snapshot-at-the-begining(SATB);
  5) **Copy/Clean up** 多线程清除失活对象，会有STW。G1将会后区域的存活对象拷贝到新区域，清除Remember Sets,并发清空回收区域并把它返回到空闲区域链表中。

![Copy-Clean up](..\images\java\Copy-Clean up.png)
  6) 复制/清除过程后，回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。
 ![复制-清除过程后](..\images\java\复制-清除过程后.png)

